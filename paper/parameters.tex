\section{Choice of parameters}
\label{sec:parameters}

    Along the description of algorithms the previous sections also contain
    estimates of the runtime the algorithms take to be performed.
    In most cases, the runtime depends on the number of elements involved.
    Since the set implementation described in this document consists of
    a hierarchy of data structures, the number of subdivisions in a layer
    can be influenced to optimize the overall runtime expected for an
    operation.

    The most interesting data structures in this respect are the hash table
    and the AVL tree.
    The fact that the AVL tree incorporates bloom filters for each subtree has
    a positive impact on the runtime complexity of many operations.

    \subsection{Runtime complexity of AVL insertion with bloom}
    \label{sec:parameters-AVL_insert_bloom}

        If we search a regular AVL for a specific element, the complexity class
        is $O(log(n))$ where $n$ is the number of nodes in the AVL.
        In our AVL, however, the element has to pass a bloom filter for each
        node the algorithm traverses.
        If the element is in the set represented by an AVL, nothing changes in
        terms of runtime complexity.
        However, if the element is \emph{not} in the set, the test may fail at
        some point, causing the search to terminate possibly much earlier.

        The probability of the bloom filter not denying than an element may be
        in a set, when it really is not in the set, may be approximated by:
        %TODO: ref

        \begin{equation}
            p_\mathrm{pos} =
            \left(1 - \left(1 - \frac{1}{m}\right)^{kn}\right)^k
            \label{eq:parameters-AVL_bloom-false_pos}
        \end{equation}

        Where $m$ is the width of the bloom filter and $k$ is the number of hash
        functions used for the bloom filter.
        The probability of this check to, correctly, cause the algorithms to
        terminate early on one level $l$, implies that the algorithm traversed
        $l$ nodes:

        \begin{equation}
            p_\mathrm{level} = \prod_{i<l} p_\mathrm{pos}(i) =
            \prod_{i<l} \left(1 - \left(1 - \frac{1}{m}\right)^{kn(i)}\right)^k
        \end{equation}

        The runtime complexity may now be given by the summing up the costs of
        passing one level ($1$), weighted by the probability of passing the
        levels up to that one:

        \begin{equation}
            T_{\in} = \sum_l p_\mathrm{level} =
            \sum_l \prod_{i<l}
            \left(1 - \left(1 - \frac{1}{m}\right)^{kn(i)}\right)^k
            \label{eq:parameters-AVL_find-T}
        \end{equation}

        The ``find'' operation is expected to be effectively faster using the
        bloom filter.
        Figure \ref{fig:parameters-AVL_bloom-runtime_find} on page
        \ref{fig:parameters-AVL_bloom-runtime_find} visualizes the expected
        runtime for a range of heights.
        It also shows that the effect variates only a little for a small range
        of possible $k$, which will prove interesting in the following section.

        \begin{figure}[!h]
            \caption{Runtime complexity of ``find''-operation}
            \label{fig:parameters-AVL_bloom-runtime_find}
            \begin{center}
                \includegraphics{fig/runtime-avl.1}

                with $m=64$
            \end{center}
        \end{figure}

    \subsection{Runtime complexity of AVL intersection with bloom}
    \label{sec:parameters-AVL_intersect_bloom}

        Much more interesting is the intersection of two AVLs.
        As stated in equation \ref{eq:bloom_filter-disjunctive_sets-bitwise_and}
        on page \pageref{eq:bloom_filter-disjunctive_sets-bitwise_and}, two sets
        are exclusively disjunctive if the result of a bitwise ``AND''-operation
        of the two corresponding bloom filters has less than $k$ bits set.
        For the sets \emph{not} to be disjunctive, $m-k+1$ bits must be set.

        Now consider two exclusively disjunctive sets $A$ and $B$.
        For the calculation of the probability that those two sets will be found
        exclusively disjunctive by a comparison of the bloom filters may only
        be based on the probabilities of both the two bits of the two bloom
        filters at a position being true.
        Therefore the probability of two sets $A$ and $B$ represented by two
        bloom filters $a$ and $b$ may be given as:

        \begin{equation}
            p_{\mathrm{A \cap B = \emptyset}}(a, b) =
            \left( 1 - p_{a_i = 1}(a) \cdot p_{b_i = 1}(b) \right)^{m-k+1}
        \end{equation}

        Or

        \begin{equation}
            p_{\mathrm{A \cap B = \emptyset}}(a, b) =
            \left( 1 -
                \left(1 - \zeta^{kn_a} \right) \cdot
                \left(1 - \zeta^{kn_b} \right)
            \right)^{m-k+1}
            \qquad \zeta = 1 - \frac{1}{m}
        \end{equation}

        If we assume that, in both sets, the number of bits set is equal
        ($n = n_a = n_b$), the term may be simplified to:

        \begin{equation}
            p_{\mathrm{A \cap B = \emptyset}}(n) =
            \left( \zeta^{2kn} -2\zeta^{kn} \right)^{m-k+1}
        \end{equation}

        Similar to the ``find`` operation, finding that two sets $A$ and $B$ are
        exclusively disjunctive may cause an early return, since none of the nodes
        below the current node have to be processed.
        Therefore, the probability of a node being processed may be given as:

        \begin{equation}
            p_\mathrm{level} =
            \prod_{i<l} p_{\mathrm{A \cap B \neg \emptyset}}(n(i))
        \end{equation}

        As each node has to be processed, the expected average runtime may be
        given as the sum of the nodes in each layer, weighted by the probability
        of reaching that layer.

        \begin{equation}
            T_{\cap} = \sum_l p_\mathrm{level} =
            \sum_l 2^l \prod_{i<l} p_{\mathrm{A \cap B \neg \emptyset}}(n(i))
        \end{equation}

        In conclusion:

        \begin{equation}
            T_{\cap} = \sum_l p_\mathrm{level} =
            \sum_l 2^l \prod_{i<l} \left(1 - \left(
                \zeta^{2kn(i)} -2\zeta^{kn(i)}
            \right)^{m-k+1} \right)
        \end{equation}

        If we plot the expected runtime vs. the height of an AVL for a range of
        $k$, we observe a minimal runtime for $k=3$.

        \begin{figure}[!h]
            \caption{Runtime complexity of ``$\cap$''-operation}
            \label{fig:parameters-AVL_bloom-runtime_intersection}
            \begin{center}
                \includegraphics{fig/runtime-avl.2}

                with $m=64$
            \end{center}
        \end{figure}

